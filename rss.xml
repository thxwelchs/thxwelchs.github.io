<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[thxwelchs's dev-blog]]></title><description><![CDATA[개발 블로그]]></description><link>https://gatsby-casper.netlify.com</link><generator>RSS for Node</generator><lastBuildDate>Tue, 14 Jan 2020 00:40:16 GMT</lastBuildDate><item><title><![CDATA[JVM GC종류와 튜닝]]></title><description><![CDATA[GC 종류 먼저 GC에는 크게 Minor GC, Major GC, Full GC가 있는데, Minor GC와 Full GC에서는 GC를 하기위해 JVM으로부터 구동되는 애플리케이션이 모두 stop 되는 stop-the-world…]]></description><link>https://gatsby-casper.netlify.com/JVM-GC/</link><guid isPermaLink="false">https://gatsby-casper.netlify.com/JVM-GC/</guid><pubDate>Wed, 22 Aug 2018 19:11:55 GMT</pubDate><content:encoded>&lt;h1&gt;GC 종류&lt;/h1&gt;
&lt;p&gt;먼저 GC에는 크게 &lt;strong&gt;Minor GC, Major GC, Full GC&lt;/strong&gt;가 있는데, Minor GC와 Full GC에서는 GC를 하기위해 JVM으로부터 구동되는 애플리케이션이 모두 stop 되는 stop-the-world가 상태가 됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial GC
Mark-Sweep-Compact 알고리즘을 사용하며, Old Generation 영역의 객체들을 식별하면서 Heap 앞 부분부터 체크하며 살아 있는 객체는 남기고 죽은 객체는 삭제하며 힙의 앞쪽으로 모두 몰아줍니다.
이 방식은 GC 알고리즘 중 매우 느린편에 속한다, 하지만 느리게 수행하는 만큼 OS자원은 덜 소모됩니다.&lt;/li&gt;
&lt;li&gt;Parallel GC
이 방식은 Serial GC와 GC를 수행하는 방식은 같습니다, 차이점은 멀티 쓰레드로 병렬적으로 처리한다는 점입니다.
멀티 쓰레드로 처리하기 때문에 수행속도는 빠르며 대신 그만큼 OS자원은 많이 소모됩니다.&lt;/li&gt;
&lt;li&gt;CMS(Concurrent Mark-Sweep)
Parallel GC와 같이 멀티쓰레드로 처리되는 GC이며 대신 Minor GC에서 사용되는 알고리즘은 Concurrent Mark-Sweep을 사용합니다,  애플리케이션의 백그라운드에서 GC를 처리하므로 stop the world 상태가 거의 일어나지 않습니다. 백그라운드에서 GC를 수행해야 하므로 OS 리소스를 많이 소모합니다. 단점으로 중간중간에 존재하는 죽은 객체들을 삭제하며 중간에 의미없이 비어있는 메모리 공간이 생겨 메모리 파편화 현상이 발생, 그러면 결국 메모리부족 현상으로 인해 Serial GC처럼 Mark-Sweep-Compact 알고리즘으로 GC를 수행하게 됩니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1 GC&lt;/p&gt;
&lt;p&gt;CMS의 단점을 극복하기 위해 고안된 GC, Heap영역에 여러 영역을 세분화 하여(Region) 참조가 없어진 객체들을 삭제하기 위해 참조가 존재하고 사용중인 객체들은 특정 Region 영역으로 옮겨 참조가 없어진 객체들이 모여 있는 Region 을 통째로 삭제해버리는 GC 전략, 그러면 중간중간 비어있는 메모리 공간이 줄어들어 메모리 파편화를 해결해줄 수 있다고 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;JVM VM option&lt;/h2&gt;
&lt;h4&gt;Serial GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-XX:+UseSerialGC	&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Parallel GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-XX:+UseParallelGC&lt;/li&gt;
&lt;li&gt;-XX:ParallelGCThreads=value	 &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Parallel Compacting GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-XX:+UseParallelOldGC	 &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;CMS GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-XX:+UseConcMarkSweepGC&lt;/li&gt;
&lt;li&gt;-XX:+UseParNewGC&lt;/li&gt;
&lt;li&gt;-XX:+CMSParallelRemarkEnabled&lt;/li&gt;
&lt;li&gt;-XX:CMSInitiatingOccupancyFraction=value&lt;/li&gt;
&lt;li&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;G1 GC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-XX:+UnlockExperimentalVMOptions&lt;/li&gt;
&lt;li&gt;-XX:+UseG1GC&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Java Version별 default GC&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JDK 5, 6 - Serial GC&lt;/li&gt;
&lt;li&gt;JDK 7 - Parallel GC&lt;/li&gt;
&lt;li&gt;JDK 8 - Parallel GC (G1GC라는 글도 있어 직접 설치된 jdk 기준으로 default GC를 살펴본 결과 Parallel GC 였습니다.)&lt;/li&gt;
&lt;li&gt;JDK 9 - G1 GC&lt;/li&gt;
&lt;li&gt;JDK 10 - G1 GC&lt;/li&gt;
&lt;li&gt;JDK 11 - G1 GC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현재 내 jdk default gc 살펴보기&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;shell&quot;&gt;&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ java -XX:+PrintCommandLineFlags -version&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;현재 내 jdk default gc 변경하기&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;shell&quot;&gt;&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ java -XX:+UseG1GC -XX:+PrintCommandLineFlags -version&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Welcome to Ghost]]></title><description><![CDATA[👋 Welcome, it’s great to have you here. We know that first impressions are important, so we’ve populated your new site with some initial…]]></description><link>https://gatsby-casper.netlify.com/welcome/</link><guid isPermaLink="false">https://gatsby-casper.netlify.com/welcome/</guid><pubDate>Sun, 06 May 2018 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;👋 Welcome, it’s great to have you here.&lt;/p&gt;
&lt;p&gt;We know that first impressions are important, so we’ve populated your new site with some initial &lt;strong&gt;getting started&lt;/strong&gt; posts that will help you get familiar with everything in no time. This is the first one!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A few things you should know upfront&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ghost is designed for ambitious, professional publishers who want to actively build a business around their content. That’s who it works best for. &lt;/li&gt;
&lt;li&gt;The entire platform can be modified and customised to suit your needs. It’s very powerful, but does require some knowledge of code. Ghost is not necessarily a good platform for beginners or people who just want a simple personal blog. &lt;/li&gt;
&lt;li&gt;For the best experience we recommend downloading the Ghost Desktop App for your computer, which is the best way to access your Ghost site on a desktop device. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ghost is made by an independent non-profit organisation called the Ghost Foundation. We are 100% self funded by revenue from our Ghost(Pro) service, and every penny we make is re-invested into funding further development of free, open source technology for modern publishing.  &lt;/p&gt;
&lt;p&gt;The version of Ghost you are looking at right now would not have been made possible without generous contributions from the open source community.  &lt;/p&gt;
&lt;h2&gt;Next up, the editor&lt;/h2&gt;
&lt;p&gt;The main thing you’ll want to read about next is probably: the Ghost editor. This is where the good stuff happens.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By the way, once you’re done reading, you can simply delete the default &lt;strong&gt;Ghost&lt;/strong&gt; user from your team to remove all of these introductory posts! &lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[AOP 관점지향프로그래밍]]></title><description><![CDATA[AOP…]]></description><link>https://gatsby-casper.netlify.com/AOP/</link><guid isPermaLink="false">https://gatsby-casper.netlify.com/AOP/</guid><pubDate>Tue, 22 Aug 2017 18:31:55 GMT</pubDate><content:encoded>&lt;h1&gt;AOP&lt;/h1&gt;
&lt;p&gt;직역하면 &lt;strong&gt;관점지향프로그래밍&lt;/strong&gt; 인데, 한국말로 들으면 전혀 와닿지 않습니다.&lt;/p&gt;
&lt;p&gt;좀 더 이해가 가기 쉬운 의미로 해석해보자면, &lt;strong&gt;애플리케이션 전체에 걸쳐 사용되는 기능을 재사용하도록 지원하는 것&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;실무에서는 흔히 공통적인 흐름의 코드를 적용시켜 줄 때 주로 사용합니다.&lt;/p&gt;
&lt;p&gt;지금 이 글에서는 AOP를 구현하는 방법들에 대해 이론만 설명하겠습니다.&lt;/p&gt;
&lt;p&gt;AOP를 구현하는 방뻡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컴파일
코드 파일을 컴파일링 할 때 AspectJ 라는 걸로 AOP를 구현하는 코드를 넣은 것 처럼 컴파일 해줍니다.&lt;/li&gt;
&lt;li&gt;바이트 코드 조작
컴파일 된 클래스 파일에는 실제로 AOP에 대한 코드는 컴파일 되어있지 않지만, 코드를 실행하기 위해 클래스 로더가 클래스를  읽을 때 메모리 상에서 바이트 코드를 조작하여 AOP를 구현 해줍니다. (이것 역시 AspectJ에서도 지원)&lt;/li&gt;
&lt;li&gt;프록시 패턴
스프링에서 사용하는 핵심적인 기능
&lt;strong&gt;Proxy:&lt;/strong&gt; 클라이언트 레벨에서의 코드 변경이 필요하지 않게 하면서, 실제 내부적으로는 같은 인터페이스를 구현하고 있는 원래의 클래스를 감싸고 있는 형태의 대체 객체를 사용하는 것입니다.
스프링 에서는 이러한 개념을 사용해서  AOP를 프록시 객체에서 구현 해줍니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- ### 참고 --&gt;
&lt;!-- &gt; [https://jojoldu.tistory.com/71](https://jojoldu.tistory.com/71)
&quot;백기선&quot;님의 스프링 프레임워크 AOP강좌 --&gt;</content:encoded></item><item><title><![CDATA[Java Reflection]]></title><description><![CDATA[Java Reflection 객체를 통해서 객체 클래스 정보를 분석해내는 프로그래밍법을 의미한다.
또한 위키백과에서 설명하기로는 컴퓨터 과학에서의 Reflection…]]></description><link>https://gatsby-casper.netlify.com/reflection/</link><guid isPermaLink="false">https://gatsby-casper.netlify.com/reflection/</guid><pubDate>Mon, 22 Aug 2016 15:11:55 GMT</pubDate><content:encoded>&lt;h1&gt;Java Reflection&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;객체를 통해서 객체 클래스 정보를 분석해내는 프로그래밍법&lt;/strong&gt;을 의미한다.
또한 위키백과에서 설명하기로는 컴퓨터 과학에서의 Reflection(반영)은 &lt;strong&gt;런타임 시점에 사용되는 자신의 구조와 행위를 관리하고 수정할 수 있는 프로세스를 의미&lt;/strong&gt;한다고 한다.&lt;/p&gt;
&lt;h2&gt;그래도 잘 이해가 안가는 Reflection?&lt;/h2&gt;
&lt;p&gt;맞습니다. 사실 저렇게 사전적인 의미만 가지고는 사실상 잘 와닿지 않는 것 같습니다.\&lt;/p&gt;
&lt;p&gt;뭐든 예를 들어보는게 이해가 가장 잘 됐던 것 같아서, 이번에도 한가지 예를 들어보겠습니다.
아시다시피 Java는 컴파일이 필요한 컴파일언어 입니다. java파일로 코드를 작성하고 실행할 땐 컴파일된 class파일을 실행해야 하죠.\&lt;/p&gt;
&lt;p&gt;즉 Java는 기본적으로 정적인 영역에서 타입이 결정되는 언어라는 것입니다.&lt;br&gt;
그런데 미리 정의된 코드가 컴파일 되어 실행되기 때문에 런타임 시점에 타입을 알아야 하는 경우라면??&lt;/p&gt;
&lt;p&gt;이럴 때 사용되는 개념이 &lt;strong&gt;Reflection&lt;/strong&gt;입니다.
\&lt;/p&gt;
&lt;p&gt;이제 이론적인 설명보다는 코드로서 예를 들어보겠습니다.\&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;결론&lt;/h1&gt;
&lt;p&gt;아직 작성중…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[직렬화(Serialization)!?]]></title><description><![CDATA[직렬화 객체의 상태를 저장하기 위해서 객체를 byte stream 으로 변환하는 것을 의미한다. 그 반대는 deserialization(역직렬화) 라고 한다. 흠.. 직렬화를 알고 싶었는데 stream?이 또 뭐란 말인가? 컴퓨터의 stream…]]></description><link>https://gatsby-casper.netlify.com/serialization-marshalling/</link><guid isPermaLink="false">https://gatsby-casper.netlify.com/serialization-marshalling/</guid><pubDate>Sat, 20 Aug 2016 15:11:55 GMT</pubDate><content:encoded>&lt;h1&gt;직렬화&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;객체의 상태를 저장하기 위해서 객체를 byte stream 으로 변환하는 것&lt;/strong&gt;을 의미한다. 그 반대는 &lt;strong&gt;deserialization(역직렬화)&lt;/strong&gt; 라고 한다.&lt;br&gt;
흠.. 직렬화를 알고 싶었는데 stream?이 또 뭐란 말인가? 컴퓨터의 stream에 대한 정의는 다음과 같다.&lt;/p&gt;
&lt;h2&gt;스트림&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;배열이나 문자열 같은 데이터 컬렉션&lt;/strong&gt;을 말하며, &lt;strong&gt;자료를 입출력하기 위하여 사용하는 것&lt;/strong&gt;이다. 프로그램과 입출력 장치 사이에서 입출력 자료들을 중계하는 역할을 담당한다. 즉, 입출력 과정에서 데이터들이 자유롭게 움직일 수 있도록 중간 다리 역할을 함&lt;/p&gt;
&lt;p&gt;보통 직렬화는 서로 다른 패러다임의 프로그램의 입출력 데이터가 이동되어야 할 때 사용하는데,&lt;br&gt;
사실 이 직렬화의 개념을 이해하기 위해선 &lt;strong&gt;마샬링&lt;/strong&gt;이란 개념부터 이야기 해야 되는데..ㅋㅋ
그럼 마샬링이란건 또 뭘까!?&lt;/p&gt;
&lt;h2&gt;마샬링&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;객체의 메모리 구조를 저장이나 전송을 위해서 적당한 자료형태로 변형하는 것&lt;/strong&gt;을 의미함.&lt;/p&gt;
&lt;p&gt;Marshalling 은 보통 서로 다른 컴퓨터 혹은 서로 다른 프로그램 간에 데이터가 이동되어야 할 경우 사용됨.&lt;/p&gt;
&lt;p&gt;오케이 그럼 직렬화, 마샬링 에 대해서 어느정도 감을 잡긴 했는데 마샬링과 직렬화의 구체적인 차이는 뭘까 언뜻 보기엔 둘다 객체를 저장하려고 데이터 변형을 하는 것 같은데?&lt;/p&gt;
&lt;h2&gt;직렬화, 마샬링의 차이&lt;/h2&gt;
&lt;p&gt;마샬링은 매개 변수를 출발지에서부터 가져 오는 것이지만 직렬화는 구조화 된 데이터를 byte stream과 같은 기본 형식으로 복사하거나 복사하는 것이라고 한다.
이러한 의미에서 직렬화는 마샬링을 수행하는 수단 중 하나이며 일반적으로 값별 의미 전달을 구현합니다.&lt;/p&gt;
&lt;h1&gt;결론&lt;/h1&gt;
&lt;p&gt;아하 직렬화는 마샬링을 수행하는 수단 중 하나이자, 객체의 상태를 저장하기 위해서 byte stream 형태로 변환해주는 행위이구나&lt;/p&gt;</content:encoded></item></channel></rss>