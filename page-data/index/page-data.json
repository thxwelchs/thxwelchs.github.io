{"componentChunkName":"component---src-templates-index-tsx","path":"/","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQY003QwUoCURiG4WOExAQVuapFkUFg2cbIKDQMLY1iKMukJEvSMLR0FYqg0K42Ea1aSMsuoe6kVXQHYovGWc3pPTATLh6+/3wzwxx+kQqcLiUC9WpyQZ/8eHsXX5/fbinlkGVZgvznnPt6j5rhYtacXpz5ay+56I0M+WJpiqOeYWbIW8xgFn54MY8JLCOMQ/vZFlqYwro43sw8puNl0zMSiVOcG7+9bfIBJ7hHBXdoo4FnbqOySl6Sc3hCCU2hrxZfKxs1uaYFdYqYaZhZcgcHuEaSD9XLZfUTZpW72EceEaQQRVEs+gqh7MpV8yK4N6128NPpjtn7cNu7GoCrb3caRu15mN6ZBzH+B9oQInTA7ID+AAAAAElFTkSuQmCC","width":400,"height":90,"src":"/static/8637e594ca86d58e20988ba8c4cfc1e7/497c6/thxwelchs-logo-v2.png","srcSet":"/static/8637e594ca86d58e20988ba8c4cfc1e7/497c6/thxwelchs-logo-v2.png 1x"}}},"header":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAcOiQL//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAEAAwAAAAAAAAAAAAAAAAABABAR/9oACAEBAAE/ISJlf//aAAwDAQACAAMAAAAQ/A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAWEAEBAQAAAAAAAAAAAAAAAAABERD/2gAIAQEAAT8QFZu//9k=","aspectRatio":2.9940119760479043,"src":"/static/f55e924eff608d71da37e57b398c587d/a41d1/blog-cover.jpg","srcSet":"/static/f55e924eff608d71da37e57b398c587d/0f3a1/blog-cover.jpg 500w,\n/static/f55e924eff608d71da37e57b398c587d/a7715/blog-cover.jpg 1000w,\n/static/f55e924eff608d71da37e57b398c587d/a41d1/blog-cover.jpg 2000w","sizes":"(max-width: 2000px) 100vw, 2000px"}}},"allMarkdownRemark":{"edges":[{"node":{"timeToRead":4,"frontmatter":{"title":"UML과 코드로 이해하는 의존성","date":"2021-11-20T11:31:54Z","tags":["java","object","객체지향","의존성"],"draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/webp;base64,UklGRkoAAABXRUJQVlA4ID4AAACQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJaQAAW+virGAqOewAAP73fQKTnIxm29WJK92cxDc7Aj1VUAAAAA==","aspectRatio":1.7816091954022988,"src":"/static/9da7db0923a63c86a5d390492aca3fde/ed80f/postbg.webp","srcSet":"/static/9da7db0923a63c86a5d390492aca3fde/30305/postbg.webp 930w,\n/static/9da7db0923a63c86a5d390492aca3fde/ed80f/postbg.webp 1424w","sizes":"(max-width: 1424px) 100vw, 1424px"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/192fd/thxwelchs.png"}}]}}},"excerpt":"의존성 의존성이란 무엇일까? 우리는 객체지향 프로그래밍을 하면서 의존성이란 의미를 정말 가슴 깊이 받아들이고 있을까? 적어도 난 그렇지 않았던 것 같다.. 그래서 맨날 보면서도 까먹는 의존관계 UML 화살표 방향과 코드로써 의존관계를 명확하게 표현해…","fields":{"layout":"post","slug":"/UML과코드로이해하는의존성/"}}},{"node":{"timeToRead":6,"frontmatter":{"title":"내 redis가 해킹당했다고? 심지어 local인데?","date":"2021-08-29T07:31:54Z","tags":["redis"],"draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/webp;base64,UklGRnoAAABXRUJQVlA4IG4AAACQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJYwC+SBu0qjemzRWAAP73gmhaXllxWxzoNy7BxWo3JF9iHdaoC9v7w6lxxSmV9oV8Ja/unpFbNwNXRsFIKTCIKtz0++KfMuV/BlytrAYf6Dzw6AAAAA==","aspectRatio":1.7816091954022988,"src":"/static/74cebb81aa653cf91cde1ea672c18160/ed80f/postbg.webp","srcSet":"/static/74cebb81aa653cf91cde1ea672c18160/30305/postbg.webp 930w,\n/static/74cebb81aa653cf91cde1ea672c18160/ed80f/postbg.webp 1424w","sizes":"(max-width: 1424px) 100vw, 1424px"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/192fd/thxwelchs.png"}}]}}},"excerpt":"사건의 발단 어느날.. redis와 관련된 기능을 개발해야 할 일이 있어 redis를 local에서 docker 컨테이너로 실행 후 테스트를 해보고 있었습니다. 기능은 아주 간단해서 어떤 특정한 상황 때 hash 자료구조로 redis에 key val…","fields":{"layout":"post","slug":"/내redis가해킹당했다고심지어local인데/"}}},{"node":{"timeToRead":5,"frontmatter":{"title":"Embedded Tomcat과 Tomcat의 차이","date":"2021-08-28T08:42:30Z","tags":["springboot","tomcat"],"draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEklEQVQoz6VSTU/DMAzt3+UvIPFTOCFx48SFU6eJAwdaBIjuo6gCtq5paYfYljRJY6fzWsQKGgI0K4mcJz/72YlT72HOnyNts34g241BN6JBbFVVFizBFmskB2tjDCL+XllrXSnzPB9dRudD5o9Sf8CuheRKqg8ypadztXq/vzrlC0Y+JaaCQghdaap5k/SOvSM/7YVvdxl/AQSlOmQAG9z23bPDPH1qdXue57ou5xwBDeqlWsRxkL2ON/GIUsqtbMaS2Swp5svpZCoEJ4RoZVlSEEmga57FFycHcdhvdMEXcmek33sGgKIohoOHKHoMx0Ge54RT3h0Da/v/dIhZNiYltalpt3II/9c773hqZ58ftgYYsn9LI+SvBgAAAABJRU5ErkJggg==","aspectRatio":1.7816091954022988,"src":"/static/e32a388ddc20368c5152e91fc90b7748/6af1e/postbg.png","srcSet":"/static/e32a388ddc20368c5152e91fc90b7748/c5c6c/postbg.png 930w,\n/static/e32a388ddc20368c5152e91fc90b7748/6af1e/postbg.png 1424w","sizes":"(max-width: 1424px) 100vw, 1424px"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/192fd/thxwelchs.png"}}]}}},"excerpt":"이번 포스팅에서는 내장톰캣과 설치형으로 사용하는 외장톰캣이 무엇이 다른지, 그리고 내장톰캣으로는 해결 할 수 없는것이 있는지\n간단하게 알아보았습니다.\n포스팅 내용을 작성하기 전 이 내용을 조사해본 것은 전 직장 동료분과 오랜만에 만나 개발 담소를 나…","fields":{"layout":"post","slug":"/EmbeddedTomcat과Tomcat의차이/"}}},{"node":{"timeToRead":2,"frontmatter":{"title":"JPA 양방향 Entity 무한재귀 문제해결","date":"2020-03-06T22:47:00.000Z","tags":["kotlin","jpa","entity"],"draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHuV1BI/8QAGBABAQADAAAAAAAAAAAAAAAAAQIAESD/2gAIAQEAAQUCreFK8f/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAQADAAAAAAAAAAAAAAAAAAEAIDL/2gAIAQEABj8CmUr/AP/EABoQAAICAwAAAAAAAAAAAAAAAAEhAEERIDH/2gAIAQEAAT8hwMcFR0QvX//aAAwDAQACAAMAAAAQ9w//xAAWEQADAAAAAAAAAAAAAAAAAAAQESH/2gAIAQMBAT8QcH//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgEFAAAAAAAAAAAAAAABETEhACBBcbH/2gAIAQEAAT8QV+hKLesaEgmVIv3nb//Z","aspectRatio":1.7816091954022988,"src":"/static/4bf18ab37cd31474fd591b9287a49f4c/2cb8a/postbg.jpg","srcSet":"/static/4bf18ab37cd31474fd591b9287a49f4c/2f037/postbg.jpg 930w,\n/static/4bf18ab37cd31474fd591b9287a49f4c/2cb8a/postbg.jpg 1424w","sizes":"(max-width: 1424px) 100vw, 1424px"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/192fd/thxwelchs.png"}}]}}},"excerpt":"JPA ORM으로 개발하다보면 꽤나 많은 양방향 참조가 필요한 모델들이 있습니다. 그런데 문제는 이런 양방향관계를 가진 객체를 직렬화 하려고 할 때 무한참조가 되어 StackOverFlow를 발생시키는데요. 그렇다고 해서 ORM이 가진 장점을 포기하…","fields":{"layout":"post","slug":"/JPA 양방향 Entity 무한 재귀 문제 해결/"}}},{"node":{"timeToRead":7,"frontmatter":{"title":"Kotlin JPA Entity 모델링하기","date":"2020-03-06T22:28:00.000Z","tags":["kotlin","jpa","entity"],"draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHu01Eg/8QAGBAAAgMAAAAAAAAAAAAAAAAAAQIAESD/2gAIAQEAAQUCa4rE5//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAAgITH/2gAIAQEABj8Chi//xAAZEAACAwEAAAAAAAAAAAAAAAABEQAgIWH/2gAIAQEAAT8hIBhw7q9df//aAAwDAQACAAMAAAAQeA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEAAgMAAAAAAAAAAAAAAAABABEgQVH/2gAIAQEAAT8QFNjkQFQ0Dbj/AP/Z","aspectRatio":1.7816091954022988,"src":"/static/d4600748e32e427b776548f4d5ce4cbe/2cb8a/%EC%BD%94%ED%8B%80%EB%A6%B0JPA%EB%AA%A8%EB%8D%B8%EB%A7%81%ED%95%98%EA%B8%B0-postbg.jpg","srcSet":"/static/d4600748e32e427b776548f4d5ce4cbe/2f037/%EC%BD%94%ED%8B%80%EB%A6%B0JPA%EB%AA%A8%EB%8D%B8%EB%A7%81%ED%95%98%EA%B8%B0-postbg.jpg 930w,\n/static/d4600748e32e427b776548f4d5ce4cbe/2cb8a/%EC%BD%94%ED%8B%80%EB%A6%B0JPA%EB%AA%A8%EB%8D%B8%EB%A7%81%ED%95%98%EA%B8%B0-postbg.jpg 1424w","sizes":"(max-width: 1424px) 100vw, 1424px"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/192fd/thxwelchs.png"}}]}}},"excerpt":"최근 스프링부트를 개발 할 때 Kotlin으로 많이 개발하고 있는데요, 특히나 이 포스팅에서는, JPA Entity 모델링 을 할 때 주의해야 할 점들을 살펴보겠습니다. Entity 모델링 먼저 코틀린에서 Entity 클래스를 작성할 때는  로 선언…","fields":{"layout":"post","slug":"/Kotlin JPA Entity 모델링하기/"}}},{"node":{"timeToRead":3,"frontmatter":{"title":"ES2020","date":"2020-02-29T22:31:55.000Z","tags":["javascript","es2020","ecma script","ECMA"],"draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvSsjRX//EABgQAAMBAQAAAAAAAAAAAAAAAAECEQAg/9oACAEBAAEFAiZka8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGH/8QAFhAAAwAAAAAAAAAAAAAAAAAAACAh/9oACAEBAAY/Air/AP/EABkQAQEAAwEAAAAAAAAAAAAAAAERACAhUf/aAAgBAQABPyEBVmOkZbyea//aAAwDAQACAAMAAAAQ8A//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAWEQEBAQAAAAAAAAAAAAAAAAABEFH/2gAIAQIBAT8QQo5P/8QAGhAAAgIDAAAAAAAAAAAAAAAAAREAIEFRYf/aAAgBAQABPxAjSbhPnJN9V//Z","aspectRatio":1.7816091954022988,"src":"/static/b9d3879f84d259be41f5e4820f4ebfef/2cb8a/ES2020-postbg.jpg","srcSet":"/static/b9d3879f84d259be41f5e4820f4ebfef/2f037/ES2020-postbg.jpg 930w,\n/static/b9d3879f84d259be41f5e4820f4ebfef/2cb8a/ES2020-postbg.jpg 1424w","sizes":"(max-width: 1424px) 100vw, 1424px"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/192fd/thxwelchs.png"}}]}}},"excerpt":"2020년이 되면서 javascript 표준 규격인 ECMA script 에도 몇가지 추가된 사항들이 생겼습니다!\n 어떤 것들이 있는지 한번 살펴보겠습니다. 널 병합 연산자 (Nullish coalescing operator) 널 병합 연산자란 왼쪽…","fields":{"layout":"post","slug":"/ES2020/"}}}]}},"pageContext":{"limit":6,"skip":0,"numPages":4,"currentPage":1}},"staticQueryHashes":["3212170248","3213104607","3993936949"]}