{"componentChunkName":"component---src-templates-post-tsx","path":"/GENERIC-1/","webpackCompilationHash":"2d74408910b4a1fbc21a","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA2ElEQVQY02NgAIJIsyLfYJOSTCCTEcT//eu3IAMe8P//f+F///7B2Jhq480LdwVaJbzYsWW/NVBB1t8/fwuAtBcQ6wKxJRBbAbEFEJsCsS8QxwKxAxDbA3EtVN4TiNnABsZ5p+7yMU26v3LtLgOgYPGfP3+TgXQ20BX9QLoOiGcC2dOBdBsQTwHiXJBBQDFnIF0KUgvEnUCsAzYw0KRgVa5F4Z3GnAJhkE1AL2sDaT0gtgNiI6jr7KAudgdiLagYyIU6QKwCNBzkIxWwgWIKFoJ6xibSDFQAAMSLvx5xS4Y5AAAAAElFTkSuQmCC","width":400,"height":90,"src":"/static/8637e594ca86d58e20988ba8c4cfc1e7/647de/thxwelchs-logo-v2.png","srcSet":"/static/8637e594ca86d58e20988ba8c4cfc1e7/647de/thxwelchs-logo-v2.png 1x"}}},"markdownRemark":{"html":"<h1>Java 와일드카드 제네릭</h1>\n<p><code class=\"language-text\">&lt;?&gt;</code> 제네릭은 Unbound wildcard라고 불리며, 어떤 타입이 될지 모른다 라는 의미입니다. wildcard가 사용된 제네릭은 타입으로 들어온 타입에 대하여 관심이 없다 라는 의미도 되며 기능적인 메소드 외에 원소 값과 관련된 메소드에는 null 값만 허용됩니다.</p>\n<p>코드로 예를 들어보자면 다음과 같습니다.</p>\n\n        <deckgo-highlight-code language=\"java\" >\n          <code slot=\"code\">List&lt;?&gt; wildcards = new ArrayList&lt;&gt;();\n\nwildcards.size() // 문제없음 (원소와는 상관없는 기능적인 메소드)\nwildcards.add(1) // 컴파일 에러 남\nwildcards.add(null) // 문제없음 null은 어떤 타입의 원소든 가능</code>\n        </deckgo-highlight-code>\n      \n<h2>Upper, Lower Bound Generic</h2>\n<ul>\n<li><code class=\"language-text\">extends</code>: 공변 제네릭이라고도 하며, 구체적인 방향성을 가진 타입을 명시 ( <code class=\"language-text\">자기자신과 서브 클래스만 허용</code>) <strong><code class=\"language-text\">read</code></strong>만 가능, &#x3C;{1} extends {2}> <strong>1은 2의 서브클래스 이거나 자기 자신이어야 한다. 라고 명시하는 것과 같습니다.</strong></li>\n<li><code class=\"language-text\">super</code>: 반공변 제네릭이라고도 하며, 추상적인 방향성을 가진 타입을 명시 ( <code class=\"language-text\">자기 자신과 슈퍼 클래스만 허용</code>) <strong><code class=\"language-text\">write</code></strong>만 가능, &#x3C;{1} super {2}> <strong>1은 2의 슈퍼클래스 이거나 자기 자신이어야 한다. 라고 명시하는 것과 같습니다.</strong></li>\n</ul>\n<p>또한 자바에서는 클래스 상속은 하나만 할 수 있지만, 인터페이스는 여러개를 구현할 수 있으므로 인터페이스를 구현한 구현체도 서브클래스 이기 때문에 </p>\n<p>다음과 같이 표현이 가능하다고 합니다.</p>\n\n        <deckgo-highlight-code language=\"java\" >\n          <code slot=\"code\">class Zergling extends Unit implements GroundAttack, Burrow {\n}\n\nclass Ultralisk extends Unit implements GroudAttack {\n}\n\n\nclass D&lt;T extends Unit &amp; GroundAttack &amp; Burrow&gt; { //T에는 Zergling만 올 수 있습니다.\n\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Upper, Lower Bound wildcard 예시 코드</p>\n\n        <deckgo-highlight-code language=\"java\" >\n          <code slot=\"code\">import java.util.ArrayList;\nimport java.util.List;\n\npublic class GenericsTester {\n\n    public static void addCat(List&lt;? super Cat&gt; catList) {\n        System.out.println(&quot;Cat Added&quot;);\n    }\n\n    public static void main(String[] args) {\n        List&lt;Animal&gt; animalList= new ArrayList&lt;Animal&gt;();\n        List&lt;Cat&gt; catList= new ArrayList&lt;Cat&gt;();\n        List&lt;RedCat&gt; redCatList= new ArrayList&lt;RedCat&gt;();\n        List&lt;Dog&gt; dogList= new ArrayList&lt;Dog&gt;();\n\n            // Animal은 Cat의 슈퍼 클래스 이므로 추가가 가능하다.\n        addCat(animalList);\n\n        // Cat은 자기자신이므로 추가가 가능하다. \n        addCat(catList);\n\n        // RedCat과 Dog는 Cat의 상위클래스가 아니므로 타입 미스매치 컴파일 에러 남\n        addCat(redCatList);\n        addCat.addMethod(dogList); \n    }\n}\nclass Animal {}\n\nclass Cat extends Animal {}\n\nclass RedCat extends Cat {}\n\nclass Dog extends Animal {}</code>\n        </deckgo-highlight-code>\n      \n<p><br>\n이처럼 특정 클래스 나 메소드 안에서 특정 타입 혹은 T와 같은 제네릭 타입을 이용해서 어떤 작업을 수행하는 것이 아니라면 와일드카드를 이용하면</p>\n<p>내부 구현이 노출되지 않을 수 있고, 내부 메소드 의 의도를 조금 더 올바르게 드러낼 수 있습니다.</p>\n<br/>\n<h2>capture</h2>\n<p>와일드카드로 정의한 <code class=\"language-text\">&lt;?&gt;</code> 제네릭은 이 타입이 뭔지 모른다라고 정의를 한건데, 필요에 따라서  타입이 뭔지를 추론을 해야하는 상황일 때 capture라고 한다.</p>\n<br/>\n<h1>Kotlin 에서의 와일드카드</h1>\n<ul>\n<li><code class=\"language-text\">in T</code> : Java의 <code class=\"language-text\">? super T</code>와 같음. <code class=\"language-text\">input</code>의 약자이며 <code class=\"language-text\">write</code> 만 가능</li>\n<li><code class=\"language-text\">out T</code> : Java의 <code class=\"language-text\">? extends T</code>와 같음. <code class=\"language-text\">output</code>의 약자이며 <code class=\"language-text\">read</code> 만 가능</li>\n</ul>\n<p>kotlin에서는 out T 서브타입 한정에서 null로 값을 대입하는 것이 불가능함</p>\n<p>위 자바에서 예시를 들었던 코드를 코틀린 으로 작성했습니다.</p>\n\n        <deckgo-highlight-code language=\"kotlin\" >\n          <code slot=\"code\">class WildcardGenerics {\n    fun addCat(catList: ArrayList&lt;in Cat&gt;) {\n        println(&quot;Cat Added&quot;)\n    }\n\n\n    fun main(args: Array&lt;String&gt;) {\n        val animals = arrayListOf&lt;Animal&gt;()\n        val cats = arrayListOf&lt;Cat&gt;()\n        val redCats = arrayListOf&lt;RedCat&gt;()\n        val dogs = arrayListOf&lt;Dog&gt;()\n        \n        addCat(animals)\n        \n        addCat(cats)\n        \n        // 컴파일 에러\n        addCat(redCats)\n        addCat(dogs)\n    }\n}\n\nopen class Animal {}\n\nopen class Cat: Animal()\n\nclass RedCat: Cat()\n\nclass Dog: Animal()</code>\n        </deckgo-highlight-code>\n      \n<p><br>\n<u><span style=\"color:#e96900;\">\n혹시나 잘못된 점이 있거나 정보가 틀렸다면 반드시 코멘트 혹은 <a href=\"mailto:thxwelchs@gmail.com\">이메일</a>로 알려주시면 감사하겠습니다!\n</span></u></p>\n<h3>참고</h3>\n<blockquote>\n<p><a href=\"https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics/\">https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics</a>\n<a href=\"https://www.youtube.com/watch?v=PQ58n0hk7DI\">https://www.youtube.com/watch?v=ipT2XG1SHtQ</a> 토비님 제네릭 강의\n<a href=\"https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics/\">https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics/</a></p>\n</blockquote>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Java 와일드카드 제네릭"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<?>"}]},{"type":"text","value":" 제네릭은 Unbound wildcard라고 불리며, 어떤 타입이 될지 모른다 라는 의미입니다. wildcard가 사용된 제네릭은 타입으로 들어온 타입에 대하여 관심이 없다 라는 의미도 되며 기능적인 메소드 외에 원소 값과 관련된 메소드에는 null 값만 허용됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"코드로 예를 들어보자면 다음과 같습니다."}]},{"type":"text","value":"\n\n        "},{"type":"element","tagName":"deckgo-highlight-code","properties":{"language":"java"},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"List<?> wildcards = new ArrayList<>();\n\nwildcards.size() // 문제없음 (원소와는 상관없는 기능적인 메소드)\nwildcards.add(1) // 컴파일 에러 남\nwildcards.add(null) // 문제없음 null은 어떤 타입의 원소든 가능"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n      \n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Upper, Lower Bound Generic"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"extends"}]},{"type":"text","value":": 공변 제네릭이라고도 하며, 구체적인 방향성을 가진 타입을 명시 ( "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"자기자신과 서브 클래스만 허용"}]},{"type":"text","value":") "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"read"}]}]},{"type":"text","value":"만 가능, <{1} extends {2}> "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"1은 2의 서브클래스 이거나 자기 자신이어야 한다. 라고 명시하는 것과 같습니다."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"super"}]},{"type":"text","value":": 반공변 제네릭이라고도 하며, 추상적인 방향성을 가진 타입을 명시 ( "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"자기 자신과 슈퍼 클래스만 허용"}]},{"type":"text","value":") "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"write"}]}]},{"type":"text","value":"만 가능, <{1} super {2}> "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"1은 2의 슈퍼클래스 이거나 자기 자신이어야 한다. 라고 명시하는 것과 같습니다."}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"또한 자바에서는 클래스 상속은 하나만 할 수 있지만, 인터페이스는 여러개를 구현할 수 있으므로 인터페이스를 구현한 구현체도 서브클래스 이기 때문에 "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"다음과 같이 표현이 가능하다고 합니다."}]},{"type":"text","value":"\n\n        "},{"type":"element","tagName":"deckgo-highlight-code","properties":{"language":"java"},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"class Zergling extends Unit implements GroundAttack, Burrow {\n}\n\nclass Ultralisk extends Unit implements GroudAttack {\n}\n\n\nclass D<T extends Unit & GroundAttack & Burrow> { //T에는 Zergling만 올 수 있습니다.\n\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n      \n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Upper, Lower Bound wildcard 예시 코드"}]},{"type":"text","value":"\n\n        "},{"type":"element","tagName":"deckgo-highlight-code","properties":{"language":"java"},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"import java.util.ArrayList;\nimport java.util.List;\n\npublic class GenericsTester {\n\n    public static void addCat(List<? super Cat> catList) {\n        System.out.println(\"Cat Added\");\n    }\n\n    public static void main(String[] args) {\n        List<Animal> animalList= new ArrayList<Animal>();\n        List<Cat> catList= new ArrayList<Cat>();\n        List<RedCat> redCatList= new ArrayList<RedCat>();\n        List<Dog> dogList= new ArrayList<Dog>();\n\n            // Animal은 Cat의 슈퍼 클래스 이므로 추가가 가능하다.\n        addCat(animalList);\n\n        // Cat은 자기자신이므로 추가가 가능하다. \n        addCat(catList);\n\n        // RedCat과 Dog는 Cat의 상위클래스가 아니므로 타입 미스매치 컴파일 에러 남\n        addCat(redCatList);\n        addCat.addMethod(dogList); \n    }\n}\nclass Animal {}\n\nclass Cat extends Animal {}\n\nclass RedCat extends Cat {}\n\nclass Dog extends Animal {}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n      \n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n이처럼 특정 클래스 나 메소드 안에서 특정 타입 혹은 T와 같은 제네릭 타입을 이용해서 어떤 작업을 수행하는 것이 아니라면 와일드카드를 이용하면"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"내부 구현이 노출되지 않을 수 있고, 내부 메소드 의 의도를 조금 더 올바르게 드러낼 수 있습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"capture"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"와일드카드로 정의한 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<?>"}]},{"type":"text","value":" 제네릭은 이 타입이 뭔지 모른다라고 정의를 한건데, 필요에 따라서  타입이 뭔지를 추론을 해야하는 상황일 때 capture라고 한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Kotlin 에서의 와일드카드"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"in T"}]},{"type":"text","value":" : Java의 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"? super T"}]},{"type":"text","value":"와 같음. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"input"}]},{"type":"text","value":"의 약자이며 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"write"}]},{"type":"text","value":" 만 가능"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"out T"}]},{"type":"text","value":" : Java의 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"? extends T"}]},{"type":"text","value":"와 같음. "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"output"}]},{"type":"text","value":"의 약자이며 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"read"}]},{"type":"text","value":" 만 가능"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"kotlin에서는 out T 서브타입 한정에서 null로 값을 대입하는 것이 불가능함"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위 자바에서 예시를 들었던 코드를 코틀린 으로 작성했습니다."}]},{"type":"text","value":"\n\n        "},{"type":"element","tagName":"deckgo-highlight-code","properties":{"language":"kotlin"},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"class WildcardGenerics {\n    fun addCat(catList: ArrayList<in Cat>) {\n        println(\"Cat Added\")\n    }\n\n\n    fun main(args: Array<String>) {\n        val animals = arrayListOf<Animal>()\n        val cats = arrayListOf<Cat>()\n        val redCats = arrayListOf<RedCat>()\n        val dogs = arrayListOf<Dog>()\n        \n        addCat(animals)\n        \n        addCat(cats)\n        \n        // 컴파일 에러\n        addCat(redCats)\n        addCat(dogs)\n    }\n}\n\nopen class Animal {}\n\nopen class Cat: Animal()\n\nclass RedCat: Cat()\n\nclass Dog: Animal()"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n      \n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"u","properties":{},"children":[{"type":"element","tagName":"span","properties":{"style":"color:#e96900;"},"children":[{"type":"text","value":"\n혹시나 잘못된 점이 있거나 정보가 틀렸다면 반드시 코멘트 혹은 "},{"type":"element","tagName":"a","properties":{"href":"mailto:thxwelchs@gmail.com"},"children":[{"type":"text","value":"이메일"}]},{"type":"text","value":"로 알려주시면 감사하겠습니다!\n"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"참고"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics/"},"children":[{"type":"text","value":"https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"https://www.youtube.com/watch?v=PQ58n0hk7DI"},"children":[{"type":"text","value":"https://www.youtube.com/watch?v=ipT2XG1SHtQ"}]},{"type":"text","value":" 토비님 제네릭 강의\n"},{"type":"element","tagName":"a","properties":{"href":"https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics/"},"children":[{"type":"text","value":"https://thdev.tech/kotlin/androiddev/2017/10/03/Kotlin-Generics/"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"excerpt":"Java 와일드카드 제네릭  제네릭은 Unbound wildcard라고 불리며, 어떤 타입이 될지 모른다 라는 의미입니다. wildcard…","timeToRead":3,"frontmatter":{"title":"제네릭 1편 와일드카드 (Generic Wildcard)","userDate":"30 January 2020","date":"2020-01-30T23:11:55.000Z","tags":["java","kotlin","generic","제네릭"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAE/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHFDqER/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Air/AP/EABkQAAIDAQAAAAAAAAAAAAAAAAERABBBUf/aAAgBAQABPyEI6ohxQoz/2gAMAwEAAgADAAAAEGAP/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8QiP/EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EKr/xAAaEAEAAgMBAAAAAAAAAAAAAAABABEhMVFh/9oACAEBAAE/EADYp03CzNHoxmsW2LM//9k=","aspectRatio":1.7786458333333333,"src":"/static/87b63e2a455e147c2dc9ef644dc60032/d8826/WILDCARD-GENERIC-postbg.jpg","srcSet":"/static/87b63e2a455e147c2dc9ef644dc60032/f8f18/WILDCARD-GENERIC-postbg.jpg 930w,\n/static/87b63e2a455e147c2dc9ef644dc60032/d8826/WILDCARD-GENERIC-postbg.jpg 1366w","sizes":"(max-width: 1366px) 100vw, 1366px"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAAEr0lEQVQ4y2NggIKK7GoGXRVJhv///4P54bY+WaXlRdEeOa4TdNS0V8krGa8P9J/UWFbZ4WFv6V0SFuArAFIXGhLB0FXQwIAV2Jg6MIFoBRNdRVsV6/9JniEvTaNSfyjInPxvK7j8f4xi239T3fp3egq2/8vjM6NAatMCEliwGjajZRaDv04wM4jtrOs2P9U67+x+qy33QrU2vVBSO7S2XG/x4cUOnXsrHHZtMpKMuJtll3QF6BtWkPqJld2YBvp7B4JpkJdV+VRuFKrmnD3mf/lsqFrHHxEe1pO+Hq4v8/ML/jc11u3LsEi/4qPo9L++oNgEpKcsJpsJw0Af3yiYgcwSogrnerQ6/h/WWPS807xsuZ2Gw/e8nNxfhYVF/xuSai9HSKS8t1dx+d9T2AA2sDSmENPA8NA0MN32/z+LmYzu6SqbuZ86rPb/r3HsWFZdU/KiorLyf1F63us5Lv2bbBTT//uY+//fUrfAFKSnr7AVm4EFcBeqiBtcjNFd8z9G/+H/CPnO/7kZqd+trWz/VyVl17TLd9zUDYz7Zeds+785pNUMpKcQmwsDIzMgBi78z8znoHGhyLD5/1OtQ1Vplmn7CjPz/rt6e76rtI7PyzPtui6nm3tVXc/sf05WLdjA+IRcTANdA4MhBtr+Z5Z3VLxgaFLzP1O6aXNLTsm5jNzs/xVlpZ9zLeKPGmo1XlBWqr7j6OT9Jy4uFWxgZEQ8poEyHgpg2uS/PZO+n86ZILGS//nCxQ8bM4vPhsZF/k/2iPw9wbZ2j65d/vTgoII+f7+QN3HhcZYgPbGRWAx09vaHhSGjvLjGzUwpvyX14SUH6xpqv0elxvxvC6j+H6q44Jm20aQ91lZx+1zNHd5Oq5qsA9LTWtiAaaCNtTMkgR9axSrEKXY6ISz5Qlld3Z/8rKL/ubGpf/1tGn7JaU36q6ux5aG8QvF7X22Pdy8OXJcE6ZnVMoURw0ALdWMYk8VIVe9kdV3r//KK2v+lBcV/Yy3jfomoe/43WK78USAg5LM4S9b/UsP0k8tvL+IHJ7XaekwDTfVswTQbrySHgarRzpacluM9nf0/M7PS/peY5/7fYbr0W2FUwnO3YufXztK+L9P0o/f3Hl4MLiAq86owDbR18IGFIRMnp8A1e2G3/42GNf+nerf+azKo/L9VfdbnjQazf2zXm3t5uVH/A1kx+a8p0akqID0RfhGYBmoo6IFpMV5BdiN1m63u5kl7M1X7HocrTP1fplP3f53N7JdLbCe9mWvec6NULuOLm7Hn1+bWLnmQnvzEAkwD9XQhXj6ySotZWcXzsJxK01d72xWXC4w2/W+LXvyyNb/nXU1q++95gZP21esXXnIy9PrmFRUBNtDXMwTTQHcvSLL5/G8uq4CwzkNZqa7/sjobPmVpzXtZbjcJmCt6vrQkTP61zHrx73na3f81JNT/xxVmK4H0REXEYRqYmprA4OgQD5YICgxs8fJI+KpvlHkhwqz8dIZF0cUKj5rzi9wnXS5wr7mbEZjxP9DDZ3H0nhXg8jM5MQ17ib148RQ4u7o2Mzg41HW5vaPJAQtL3SPGxlpHzewM99m7WexwD3bNganLLslHMQMA1vLffALEkU8AAAAASUVORK5CYII=","width":151,"height":151,"src":"/static/bf7f9f29887116a6d496e42f356b60db/b3147/thxwelchs.png","srcSet":"/static/bf7f9f29887116a6d496e42f356b60db/b3147/thxwelchs.png 1x"}}]}}}},"relatedPosts":{"totalCount":6,"edges":[{"node":{"id":"c9385601-2d32-55b5-841d-867c9b3bb173","timeToRead":1,"excerpt":"AOP…","frontmatter":{"title":"AOP 관점지향프로그래밍"},"fields":{"slug":"/AOP/"}}},{"node":{"id":"2baf5d38-24bb-581d-84fa-fcb7ed46d5e1","timeToRead":3,"excerpt":"Java 와일드카드 제네릭  제네릭은 Unbound wildcard라고 불리며, 어떤 타입이 될지 모른다 라는 의미입니다. wildcard…","frontmatter":{"title":"제네릭 1편 와일드카드 (Generic Wildcard)"},"fields":{"slug":"/GENERIC-1/"}}},{"node":{"id":"a5f4fa5b-ae17-519a-84ab-d791af173498","timeToRead":3,"excerpt":"낙관적 락 충돌이 발생하지 않을 거라고 낙관적으로 가정하는 방법 데이터베이스 레벨이 아닌 JPA레벨에서 버전 관리 기능을 통해 구현되어있음 테이블에 version…","frontmatter":{"title":"JPA Locking"},"fields":{"slug":"/JPA-locking/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/GENERIC-1/","prev":{"excerpt":"Exif? 디지털 카메라 등에서 사용되는 이미지 파일 메타데이터 포맷으로, 카메라가 촬영한 사진, 녹음파일에 시간 등의 각종 정보를 담기 위해 개발되었다. 즉, JPEG, TIFF 6.0과 RIFF, WAV…","timeToRead":4,"frontmatter":{"title":"Exif metadata로 이미지 회전시키기","tags":["image","metadata","Exif"],"date":"2020-01-28T20:11:55.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":2.0547945205479454,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAcakVAf/xAAXEAADAQAAAAAAAAAAAAAAAAABAhEg/9oACAEBAAEFAhK4QZ//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAABIgACESD/2gAIAQEABj8CbYtief/EABwQAAIABwAAAAAAAAAAAAAAAAEQABEhMUFhof/aAAgBAQABPyGfUAai7jx4X//aAAwDAQACAAMAAAAQ1B//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMUEQgf/aAAgBAQABPxA1aDsi395DAYZuiFLwTkdPP//Z","sizes":"(max-width: 1800px) 100vw, 1800px","src":"/static/ae9509e9487d437c55b10aeb7f3ccf31/fb184/METADATA-EXIF-postbg.jpg","srcSet":"/static/ae9509e9487d437c55b10aeb7f3ccf31/f8f18/METADATA-EXIF-postbg.jpg 930w,\n/static/ae9509e9487d437c55b10aeb7f3ccf31/fb184/METADATA-EXIF-postbg.jpg 1800w"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/b3147/thxwelchs.png"}}]}}},"fields":{"layout":"post","slug":"/METADATA-EXIF/"}},"next":{"excerpt":"주요 옵션 : 일단 병합을 한다음에 병합에 실패한 것으로 가정후 커밋은 하지 않습니다. (커밋되지 않은 코드를 스테이지에만 올려놓고 코드를 마지막으로 점검하거나, 리뷰 할 때 쓸만함 ) : fast-forward…","timeToRead":1,"frontmatter":{"title":"Git merge 스마트하게 하기","tags":["git","squash","merge"],"date":"2020-01-31T23:11:55.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.78,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuxrMWK//EABoQAAAHAAAAAAAAAAAAAAAAAAACEBEjMkH/2gAIAQEAAQUCNVpE0f/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAQADAAAAAAAAAAAAAAAAABEAIEH/2gAIAQEABj8Ci5X/xAAbEAEAAgIDAAAAAAAAAAAAAAABEBEAQSExkf/aAAgBAQABPyFok7zlW601NHmP/9oADAMBAAIAAwAAABA8D//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPxAcn//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPxBNn//EABwQAQABBAMAAAAAAAAAAAAAAAERABAhMVHR8f/aAAgBAQABPxBnUBhPGiBqXPlu604J7W//2Q==","sizes":"(max-width: 1424px) 100vw, 1424px","src":"/static/b62ab76cd5c223716bfdbe17d30064cd/771ce/GIT-MERGE-SQUASH-postbg.jpg","srcSet":"/static/b62ab76cd5c223716bfdbe17d30064cd/f8f18/GIT-MERGE-SQUASH-postbg.jpg 930w,\n/static/b62ab76cd5c223716bfdbe17d30064cd/771ce/GIT-MERGE-SQUASH-postbg.jpg 1424w"}}},"author":{"id":"thxwelchs","bio":"thxwelchs","avatar":{"children":[{"fixed":{"src":"/static/bf7f9f29887116a6d496e42f356b60db/b3147/thxwelchs.png"}}]}}},"fields":{"layout":"post","slug":"/GIT-MERGE-SQUASH/"}},"primaryTag":"java"}}}